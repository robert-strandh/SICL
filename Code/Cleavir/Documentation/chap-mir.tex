\chapter{Medium-level intermediate representation}
\label{chap-mir}

\section{Instruction graph}

The compiler translates an abstract syntax tree into a \emph{graph} of
\emph{instructions} in a language named \emph{MIR}.  This graph is a
variation on a \emph{control flow graph}.  As such, it has a unique
instruction called the \emph{initial instruction} which is the
instruction where the execution of the MIR program starts. 

In general an instruction can have zero, one, or more
\emph{successors}, and zero, one, or more \emph{predecessors}.

An instruction can also have zero, one, or several \emph{inputs} and
zero, one, or more \emph{outputs}.  An input may be an \emph{constant}
value or a \emph{lexical variable}.%
\footnote{The only exception to this rule is that an
  \texttt{enclose-instruction} has an \texttt{enter-instruction} as
  its input.}  An output may only be a lexical variable.

The execution of a a MIR instruction consists of generating the
outputs as a function of the inputs, and also of choosing a successor
based on the inputs.

The execution of a MIR program consists of starting execution at the
\emph{initial instruction} and executing a sequence of instructions
where an instruction in the sequence is the successor chosen during
the execution of the preceding instruction in the sequence.

A MIR program is said to be \emph{well formed} if and only if the
restrictions on each of the instructions are respected, as defined in
\refSec{sec-mir-instructions}.

It is possible for a well-formed MIR program to contain instructions
that are not \emph{reachable} in that there is no execution path from
the initial instruction to such an instruction.  This situation can
arise as a result of certain optimizations that determine that a
particular successor arc of some instruction can never be chosen, and
so removes that arc.  In certain cases, the instruction at the head of
that arc may then not be reachable from the initial instruction.  

Because of the existence of \texttt{enclose-instruction}s, the concept
of reachability is actually a bit more complicated than what was
hinted in the previous paragraph.  More formally, an instruction is
reachable if and only if:

\begin{itemize}
\item it is an \texttt{enter-instruction}, or
\item it has a reachable predecessor.
\end{itemize}

By stating that every \texttt{enter-instruction} is reachable a
priori, we implicitly assume that the closure generated as the output
of every \texttt{enclose-instruction} is actually \emph{used}.
Whether this is the case or not is of course \emph{undecidable}, but
the translation from an abstract syntax tree to MIR eliminates some of
the cases where the closure may not be used, in that it does not
generate output for anonymous functions that are evaluated in a
context where the resulting closure is obviously not needed.

A MIR program is said to be \emph{reduced} if and only if it is
\emph{well formed} and every instruction is \emph{reachable}. 

\section{Succession of levels of detail}

MIR is not a single representation.  Rather, it is a succession of
different representations, according to the \emph{level of detail}
that is required.  The levels are distinguished by what types of
instructions and what types of data are present. 

\subsection{Level 0}

The first level is \emph{backend independent} and mostly
implementation independent.  The dependence on the implementation
consists of what floating-point operations might be present, depending
on the different floating-point types supported.

At this level, no address calculations are exposed.  All variables
contain \cl{} objects, except that some variables may contain
\emph{unboxed} or \emph{raw} versions of such objects, in particular
integers, floating-point numbers, and characters.

Argument parsing is not exposed, and is instead hidden in a single
\texttt{enter-instruction}.  Similarly, the details of how functions
are called and how values are returned is hidden.  A single
instruction is used to access the fields of a \texttt{cons} cell, the
element of an array, and the slot of a standard instance. 

At this level, all lexical locations are treated the same way. 

\subsection{Level 1}

The transformation from the previous level to this level consists of a
\emph{closure analysis}.  Lexical locations are divided into two
sub-categories, namely \emph{simple locations} and \emph{captured
  locations}.  

A simple location is a lexical location that is assigned and used
within a single \emph{function}, which makes it possible to allocate
it in a register or in the stack frame belonging to that function.

A captured location, on the other hand, is a location that is assigned
and/or used in more than one function.  Such a variable can not be
allocated in a register or in the stack frame, and must instead be
allocated in the \emph{static runtime environment}. 

At this level, we also introduce explicit instructions for
\emph{non-local control transfers}, resulting from a
\texttt{return-from} or \texttt{go} special form where the origin is
in one function and the destination is in a different function.

\subsection{Level 2}

The distinction between simple locations and captured locations is
necessary because only simple locations are subject to conversion to
\emph{static single assignment} (SSA) form, which is what this level is
about.  

A priori, every simple location is translated this way, but
implementations can leave out some or all simple locations from this
conversion.  However, some optimizations apply only to simple
locations. 

The representation at this level is used for \emph{type inference}.
The result of this operation is that some parts of the instruction
graph may be removed.

\subsection{Level 3}

This is the first level where real implementation-specific and
backend-specific details is introduced.  The instructions to access
fields of a \texttt{cons} cell, elements of an array, or slots of a
standard object, are expanded to expose tagging and address
calculations.

This is the level where most traditional optimizations are
accomplished, such as \emph{value numbering}, \emph{redundancy
  elimination}, \emph{common subexpression elimination}, etc.

\subsection{Level 4}

At this level, \emph{registers} and \emph{stack locations} are
introduced according to the conventions for the implementation and the
backend. 

This is the level where \emph{register allocation} is accomplished.

\section{Definition of MIR instructions}
\label{sec-mir-instructions}

\subsection{Instruction \texttt{enter-instruction}}
\label{mir-instruction-enter}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & any\\
\hline
Number of predecessors & 0\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

An instruction of this type is either the initial instruction of a MIR
program, or an input to an \texttt{enclose-instruction}.  The outputs
of this instruction corresponds to the parameters the function as
follows: 

\begin{itemize}
\item There is an output for every required parameter.
\item For each optional parameter and for each keyword parameter,
  there are two outputs, one for the parameter itself and one for the
  \texttt{supplied-p} parameter.
\end{itemize}

The execution of this instruction involves parsing the arguments given
to the function, and setting the outputs accordingly.  

This instruction has an accessor named \texttt{lambda-list}.  The
lambda list of the \texttt{enter-instruction} resembles an ordinary
lambda list in that it has a number of required parameters, possibly a
\texttt{\&rest} parameter and some \texttt{\&optional} and
\texttt{\&key} parameters.  It differs from an ordinary lambda list in
the following way:

\begin{itemize}
\item Each required parameter is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.
\item If the \texttt{\&rest} lambda list keyword is present, it is
  followed by a \texttt{lexical-location} which is also one of the
  outputs of the instruction.
\item If the \texttt{\&optional} lambda list keyword is present, it is
  followed by any number of two-element lists.  Each element of each
  such lists is a \texttt{lexical-location} which is also one of the
  outputs of the instruction.  The first element represents the
  argument if it was given and the second element represents a
  \texttt{supplied-p} argument containing either \texttt{nil} or
  \texttt{t}.
\item If the \texttt{\&key} lambda list keyword is present, it is
  followed by any number of three-element lists.  The first element of
  each such list is a \emph{symbol} (typically a symbol in the
  \texttt{keyword} package) used to recognize whether the
  corresponding argument has been given.  The second element and the
  third element of each list is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.  The second element
  represents the argument if it was given and the third element
  represents a \texttt{supplied-p} argument containing either
  \texttt{nil} or \texttt{t}.
\end{itemize}

Notice that the outputs are lexical locations independently of whether
the parameters to the function are special variables.  The MIR
instructions following the \texttt{enter-instruction} are responsible
for binding special variables and assigning default values to
unsupplied \texttt{\&optional} and \texttt{\&key} parameters.

\refFig{fig-enter-instruction} shows the Graphviz illustration of the
\texttt{enter-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-enter-instruction.pdf_t}
\end{center}
\caption{\label{fig-enter-instruction}
\texttt{enter-instruction}.}
\end{figure}

\subsection{Instruction \texttt{nop-instruction}}
\label{mir-instruction-nop}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

Executing this instruction has no effect. 

\refFig{fig-nop-instruction} shows the Graphviz illustration of the
\texttt{nop-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-nop-instruction.pdf_t}
\end{center}
\caption{\label{fig-nop-instruction}
\texttt{nop-instruction}.}
\end{figure}

\subsection{Instruction \texttt{assignment-instruction}}
\label{mir-instruction-assignment}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The execution of this instruction results in the input being copied to
the output without any modification. 

\refFig{fig-assignment-instruction} shows the Graphviz illustration of the
\texttt{assignment-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-assignment-instruction.pdf_t}
\end{center}
\caption{\label{fig-assignment-instruction}
\texttt{assignment-instruction}.}
\end{figure}

\subsection{Instruction \texttt{funcall-instruction}}
\label{mir-instruction-funcall}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & any\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input of this instruction corresponds to the function being
called.  It can be either a lexical location or a global-input.  
The remaining inputs correspond to the arguments to be passed to the
callee. 

The outputs of this instruction correspond to the values that the
caller requests from the callee.  The number of outputs can therefore
be different from the actual number of values produced by the caller.

\refFig{fig-funcall-instruction} shows the Graphviz illustration of the
\texttt{funcall-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-funcall-instruction.pdf_t}
\end{center}
\caption{\label{fig-funcall-instruction}
\texttt{funcall-instruction}.}
\end{figure}

\subsection{Instruction \texttt{tailcall-instruction}}
\label{mir-instruction-tailcall}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 0\\
\hline
\end{tabular}

The first input of this instruction corresponds to the function being
called.  It can be either a lexical location or a global-input.  
The remaining inputs correspond to the arguments to be passed to the
callee. 

\refFig{fig-tailcall-instruction} shows the Graphviz illustration of the
\texttt{tailcall-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-tailcall-instruction.pdf_t}
\end{center}
\caption{\label{fig-tailcall-instruction}
\texttt{tailcall-instruction}.}
\end{figure}

\subsection{Instruction \texttt{return-instruction}}
\label{mir-instruction-return}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 0\\
\hline
\end{tabular}

The inputs of this instruction correspond to the values transmitted to
the caller

It terminates execution of the current function and returns to the
caller. 

\refFig{fig-return-instruction} shows the Graphviz illustration of the
\texttt{return-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-return-instruction.pdf_t}
\end{center}
\caption{\label{fig-return-instruction}
\texttt{return-instruction}.}
\end{figure}

\subsection{Instruction \texttt{enclose-instruction}}
\label{mir-instruction-enclose}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input of this instruction is different from those of other
instructions because it is another instruction, namely an
\texttt{enter-instruction}.

The instruction takes the instruction graph of the input and creates a
\emph{closure}.  The closure contains the current lexical runtime
environment and the code resulting from the input instruction graph.

\refFig{fig-enclose-instruction} shows the Graphviz illustration of the
\texttt{enclose-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-enclose-instruction.pdf_t}
\end{center}
\caption{\label{fig-enclose-instruction}
\texttt{enclose-instruction}.}
\end{figure}

\subsection{Instruction \texttt{test-instruction}}
\label{mir-instruction-test}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The input of this instruction is a generalized Boolean.  The first
successor is chosen if the value of the input is \emph{true} and the
second successor is chosen of the value of the input is \emph{false}.

\refFig{fig-test-instruction} shows the Graphviz illustration of the
\texttt{test-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-test-instruction.pdf_t}
\end{center}
\caption{\label{fig-test-instruction}
\texttt{test-instruction}.}
\end{figure}

\subsection{Instruction \texttt{car-instruction}}
\label{mir-instruction-car}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a \texttt{cons} cell.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is the contents of
the \texttt{car} of the \texttt{cons} cell.

\refFig{fig-car-instruction} shows the Graphviz illustration of the
\texttt{car-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-car-instruction.pdf_t}
\end{center}
\caption{\label{fig-car-instruction}
\texttt{car-instruction}.}
\end{figure}

\subsection{Instruction \texttt{cdr-instruction}}
\label{mir-instruction-cdr}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a \texttt{cons} cell.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is the contents of
the \texttt{cdr} of the \texttt{cons} cell.

\refFig{fig-cdr-instruction} shows the Graphviz illustration of the
\texttt{cdr-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-cdr-instruction.pdf_t}
\end{center}
\caption{\label{fig-cdr-instruction}
\texttt{cdr-instruction}.}
\end{figure}

\subsection{Instruction \texttt{rplaca-instruction}}
\label{mir-instruction-rplaca}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \texttt{cons} cell.  If
the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input
can be any object.  The effect of the instruction is to replace the
contents of the \texttt{car} of the \texttt{cons} cell by the second
input.

\refFig{fig-rplaca-instruction} shows the Graphviz illustration of the
\texttt{rplaca-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-rplaca-instruction.pdf_t}
\end{center}
\caption{\label{fig-rplaca-instruction}
\texttt{rplaca-instruction}.}
\end{figure}

\subsection{Instruction \texttt{rplacd-instruction}}
\label{mir-instruction-rplacd}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \texttt{cons} cell.  If
the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input
can be any object.  The effect of the instruction is to replace the
contents of the \texttt{cdr} of the \texttt{cons} cell by the second
input.

\refFig{fig-rplacd-instruction} shows the Graphviz illustration of the
\texttt{rplacd-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-rplacd-instruction.pdf_t}
\end{center}
\caption{\label{fig-rplacd-instruction}
\texttt{rplacd-instruction}.}
\end{figure}

\subsection{Instruction \texttt{slot-read-instruction}}
\label{mir-instruction-slot-read}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{standard object}.
If the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input is
a non-negative fixnum indicating the \emph{index} of the slot in the
instance.  The output is the contents of the corresponding slot.

\refFig{fig-slot-read-instruction} shows the Graphviz illustration of the
\texttt{slot-read-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-slot-read-instruction.pdf_t}
\end{center}
\caption{\label{fig-slot-read-instruction}
\texttt{slot-read-instruction}.}
\end{figure}

\subsection{Instruction \texttt{slot-write-instruction}}
\label{mir-instruction-slot-write}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 3\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{standard object}.
If the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input is
a fixnum indicating the \emph{index} of the slot in the instance.  The
third input can be any object.  The effect of the instruction is to
replace the contents of the corresponding slot by the third input.

\refFig{fig-slot-write-instruction} shows the Graphviz illustration of the
\texttt{slot-write-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-slot-write-instruction.pdf_t}
\end{center}
\caption{\label{fig-slot-write-instruction}
\texttt{slot-write-instruction}.}
\end{figure}

\subsection{Instruction \texttt{aref-instruction}}
\label{mir-instruction-aref}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{general array}.
If the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input is
a non-negative fixnum indicating the \emph{row-major index} of an
element of the array.  The output is the contents of the corresponding
element of the array.

\refFig{fig-aref-instruction} shows the Graphviz illustration of the
\texttt{aref-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-aref-instruction.pdf_t}
\end{center}
\caption{\label{fig-aref-instruction}
\texttt{aref-instruction}.}
\end{figure}

\subsection{Instruction \texttt{aset-instruction}}
\label{mir-instruction-aset}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 3\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{general array}.
If the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input is
a fixnum indicating the \emph{row-major index} of an element of the
array.  The third input can be any object.  The effect of the
instruction is to replace the contents of the corresponding element by
the third input.

\refFig{fig-aset-instruction} shows the Graphviz illustration of the
\texttt{aset-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-aset-instruction.pdf_t}
\end{center}
\caption{\label{fig-aset-instruction}
\texttt{aset-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-add-instruction}}
\label{mir-instruction-fixnum-add}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is a
\texttt{fixnum}.  

The output is the sum of the two inputs.

If the second successor is chosen, then in order to obtain the sum of the
two inputs, the following adjustment has to be made:

\begin{itemize}
\item If the output is negative, then $2^n$ must be added to the
  output, where $n$ is the number of bits used to represent a fixnum. 
\item If the output is positive, then $2^n$ must be subtracted from
  the output, where $n$ is the number of bits used to represent a
  fixnum.
\end{itemize}

\refFig{fig-fixnum-add-instruction} shows the Graphviz illustration of the
\texttt{fixnum-add-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-add-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-add-instruction}
\texttt{fixnum-add-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-sub-instruction}}
\label{mir-instruction-fixnum-sub}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is a
\texttt{fixnum}.  

The output is the difference between the two inputs.

If the second successor is chosen, then in order to obtain the difference
between the two inputs, the following adjustment has to be made:

\begin{itemize}
\item If the output is negative, then $2^n$ must be added to the
  output, where $n$ is the number of bits used to represent a fixnum. 
\item If the output is positive, then $2^n$ must be subtracted from
  the output, where $n$ is the number of bits used to represent a
  fixnum.
\end{itemize}

\refFig{fig-fixnum-sub-instruction} shows the Graphviz illustration of the
\texttt{fixnum-sub-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-sub-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-sub-instruction}
\texttt{fixnum-sub-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-<-instruction}}
\label{mir-instruction-fixnum-less}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is
strictly less than the second input.

\refFig{fig-fixnum-less-instruction} shows the Graphviz illustration of the
\texttt{fixnum-<-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-less-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-less-instruction}
\texttt{fixnum-<-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-<=-instruction}}
\label{mir-instruction-fixnum-le}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is
less than or equal to the second input.

\refFig{fig-fixnum-le-instruction} shows the Graphviz illustration of the
\texttt{fixnum-<=-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-le-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-le-instruction}
\texttt{fixnum-<=-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-=-instruction}}
\label{mir-instruction-fixnum-equal}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is equal
to the second input.

\refFig{fig-fixnum-equal-instruction} shows the Graphviz illustration of the
\texttt{fixnum-=-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-equal-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-equal-instruction}
\texttt{fixnum-=-instruction}.}
\end{figure}

\subsection{Instruction \texttt{phi-instruction}}
\label{mir-instruction-phi}

\begin{tabular}{|l|l|}
\hline
Number of inputs & > 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction is used for variables respecting the \emph{static
  single assignment} (SSA) property.  

One of the following must hold for any \texttt{phi-instruction} A:

\begin{itemize}
\item The number of predecessors of A is equal to the number of inputs
  to A, or
\item A has a single predecessor B, and B is also a
  \texttt{phi-instruction} with the same number of inputs as A.
\end{itemize}

In other words, \texttt{phi-instruction}s occur in \emph{clusters}
with the same number of inputs $n$.  The first instruction of such a
cluster has $n$ predecessors, and the others have a single
predecessor. 

Special care must be taken when the graph is modified so that this
restriction is respected. 

\refFig{fig-phi-instruction} shows the Graphviz illustration of the
\texttt{phi-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-phi-instruction.pdf_t}
\end{center}
\caption{\label{fig-phi-instruction}
\texttt{phi-instruction}.}
\end{figure}

\subsection{Instruction \texttt{typeq-instruction}}
\label{mir-instruction-typeq}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The first input of this instruction is an object of which the type
is be tested.  The second input is a \emph{type specifier}.
Initially, the second input is a \texttt{constant-input}, but that
might change as a result of transformations of the graph.  

The first successor is chosen if and only if the first input is of the
type denoted by the second input. 

This instruction is used in a variety of situations:

\begin{itemize}
\item When the source code contains a call to \texttt{typep} with a
  constant type argument, a compiler macro might transform the call to
  a special form that generates this instruction.
\item Some implementations might generate this instruction from the
  special operator \texttt{the}, where the second successor contains a
  call to \texttt{error}.
\item Since type declarations can be seen as implicit use of the
  special operator \texttt{the}, this instruction can be used for type
  declarations as well.
\item The macro \texttt{check-type} might result in this instruction
  being generated, in which case the second successor would contain
  instructions to signal a correctable error.
\end{itemize}

Because the second input may not be a \texttt{constant-input}, the
type specifier can also be retrieved using the slot reader
\texttt{value-type}. 

\refFig{fig-typeq-instruction} shows the Graphviz illustration of the
\texttt{typeq-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-typeq-instruction.pdf_t}
\end{center}
\caption{\label{fig-typeq-instruction}
\texttt{typeq-instruction}.}
\end{figure}

\subsection{Instruction \texttt{sref-instruction}}
\label{mir-instruction-sref}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a constant symbol naming a
special variable.  The output is the value of that special variable.

\refFig{fig-sref-instruction} shows the Graphviz illustration of the
\texttt{sref-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-sref-instruction.pdf_t}
\end{center}
\caption{\label{fig-sref-instruction}
\texttt{sref-instruction}.}
\end{figure}

\subsection{Instruction \texttt{sset-instruction}}
\label{mir-instruction-sset}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a constant symbol naming a
special variable.  The second input can be any object.  The effect of
the instruction is to replace the current value of the special
variable the second input.

\refFig{fig-sset-instruction} shows the Graphviz illustration of the
\texttt{sset-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-sset-instruction.pdf_t}
\end{center}
\caption{\label{fig-sset-instruction}
\texttt{sset-instruction}.}
\end{figure}

\subsection{Instruction \texttt{sbind-instruction}}
\label{mir-instruction-sbind}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a constant symbol naming a
special variable.  The second input can be any object.  The effect of
the instruction is to create a new binding for the special variable,
where the initial value is that of the second input.

The binding is automatically destroyed when the current function
invocation terminates by executing a \texttt{return-instruction}.
After an instruction of this type has been executed, control flow must
not be able to reach a \texttt{tailcall-instruction}. 

\refFig{fig-sbind-instruction} shows the Graphviz illustration of the
\texttt{sbind-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-sbind-instruction.pdf_t}
\end{center}
\caption{\label{fig-sbind-instruction}
\texttt{sbind-instruction}.}
\end{figure}

\subsection{Instruction \texttt{short-float-box-instruction}}
\label{mir-instruction-short-float-box}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be an unboxed \texttt{short-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is a boxed \texttt{short-float} value corresponding to the
input.

This instruction can be used by implementations that support the
\texttt{short-float} data type.   

\refFig{fig-short-float-box-instruction} shows the Graphviz illustration of the
\texttt{short-float-box-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-short-float-box-instruction.pdf_t}
\end{center}
\caption{\label{fig-short-float-box-instruction}
\texttt{short-float-box-instruction}.}
\end{figure}

\subsection{Instruction \texttt{short-float-unbox-instruction}}
\label{mir-instruction-short-float-unbox}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a boxed \texttt{short-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is an unboxed \texttt{short-float} value corresponding to
the input.

This instruction can be used by implementations that support the
\texttt{short-float} data type.   

\refFig{fig-short-float-unbox-instruction} shows the Graphviz illustration of the
\texttt{short-float-unbox-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-short-float-unbox-instruction.pdf_t}
\end{center}
\caption{\label{fig-short-float-unbox-instruction}
\texttt{short-float-unbox-instruction}.}
\end{figure}

\subsection{Instruction \texttt{single-float-box-instruction}}
\label{mir-instruction-single-float-box}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be an unboxed \texttt{single-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is a boxed \texttt{single-float} value corresponding to the
input.

\refFig{fig-single-float-box-instruction} shows the Graphviz illustration of the
\texttt{single-float-box-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-single-float-box-instruction.pdf_t}
\end{center}
\caption{\label{fig-single-float-box-instruction}
\texttt{single-float-box-instruction}.}
\end{figure}

\subsection{Instruction \texttt{single-float-unbox-instruction}}
\label{mir-instruction-single-float-unbox}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a boxed \texttt{single-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is an unboxed \texttt{single-float} value corresponding to
the input.

\refFig{fig-single-float-unbox-instruction} shows the Graphviz illustration of the
\texttt{single-float-unbox-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-single-float-unbox-instruction.pdf_t}
\end{center}
\caption{\label{fig-single-float-unbox-instruction}
\texttt{single-float-unbox-instruction}.}
\end{figure}

\subsection{Instruction \texttt{double-float-box-instruction}}
\label{mir-instruction-double-float-box}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be an unboxed \texttt{double-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is a boxed \texttt{double-float} value corresponding to the
input.

This instruction can be used by implementations that support the
\texttt{double-float} data type.   

\refFig{fig-double-float-box-instruction} shows the Graphviz illustration of the
\texttt{double-float-box-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-double-float-box-instruction.pdf_t}
\end{center}
\caption{\label{fig-double-float-box-instruction}
\texttt{double-float-box-instruction}.}
\end{figure}

\subsection{Instruction \texttt{double-float-unbox-instruction}}
\label{mir-instruction-double-float-unbox}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a boxed \texttt{double-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is an unboxed \texttt{double-float} value corresponding to
the input.

This instruction can be used by implementations that support the
\texttt{double-float} data type.   

\refFig{fig-double-float-unbox-instruction} shows the Graphviz illustration of the
\texttt{double-float-unbox-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-double-float-unbox-instruction.pdf_t}
\end{center}
\caption{\label{fig-double-float-unbox-instruction}
\texttt{double-float-unbox-instruction}.}
\end{figure}

\subsection{Instruction \texttt{long-float-box-instruction}}
\label{mir-instruction-long-float-box}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be an unboxed \texttt{long-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is a boxed \texttt{long-float} value corresponding to the
input.

This instruction can be used by implementations that support the
\texttt{long-float} data type.   

\refFig{fig-long-float-box-instruction} shows the Graphviz illustration of the
\texttt{long-float-box-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-long-float-box-instruction.pdf_t}
\end{center}
\caption{\label{fig-long-float-box-instruction}
\texttt{long-float-box-instruction}.}
\end{figure}

\subsection{Instruction \texttt{long-float-unbox-instruction}}
\label{mir-instruction-long-float-unbox}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a boxed \texttt{long-float}
value.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.

The output is an unboxed \texttt{long-float} value corresponding to
the input.

This instruction can be used by implementations that support the
\texttt{long-float} data type.   

\refFig{fig-long-float-unbox-instruction} shows the Graphviz illustration of the
\texttt{long-float-unbox-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-long-float-unbox-instruction.pdf_t}
\end{center}
\caption{\label{fig-long-float-unbox-instruction}
\texttt{long-float-unbox-instruction}.}
\end{figure}

\subsection{Instruction \texttt{short-float-add-instruction}}
\label{mir-instruction-short-float-add}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed short float.

The output is the sum of the two inputs.

\refFig{fig-short-float-add-instruction} shows the Graphviz illustration of the
\texttt{short-float-add-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-short-float-add-instruction.pdf_t}
\end{center}
\caption{\label{fig-short-float-add-instruction}
\texttt{short-float-add-instruction}.}
\end{figure}

\subsection{Instruction \texttt{short-float-sub-instruction}}
\label{mir-instruction-short-float-sub}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed short float.

The output is the difference between the two inputs.

\refFig{fig-short-float-sub-instruction} shows the Graphviz illustration of the
\texttt{short-float-sub-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-short-float-sub-instruction.pdf_t}
\end{center}
\caption{\label{fig-short-float-sub-instruction}
\texttt{short-float-sub-instruction}.}
\end{figure}

\subsection{Instruction \texttt{short-float-mul-instruction}}
\label{mir-instruction-short-float-mul}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed short float.

The output is the product of the two inputs.

\refFig{fig-short-float-mul-instruction} shows the Graphviz illustration of the
\texttt{short-float-mul-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-short-float-mul-instruction.pdf_t}
\end{center}
\caption{\label{fig-short-float-mul-instruction}
\texttt{short-float-mul-instruction}.}
\end{figure}

\subsection{Instruction \texttt{short-float-div-instruction}}
\label{mir-instruction-short-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed short float.

The output is the quotient of the two inputs.

\refFig{fig-short-float-div-instruction} shows the Graphviz illustration of the
\texttt{short-float-div-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-short-float-div-instruction.pdf_t}
\end{center}
\caption{\label{fig-short-float-div-instruction}
\texttt{short-float-div-instruction}.}
\end{figure}

\subsection{Instruction \texttt{single-float-add-instruction}}
\label{mir-instruction-single-float-add}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed single
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed single float.

The output is the sum of the two inputs.

\refFig{fig-single-float-add-instruction} shows the Graphviz illustration of the
\texttt{single-float-add-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-single-float-add-instruction.pdf_t}
\end{center}
\caption{\label{fig-single-float-add-instruction}
\texttt{single-float-add-instruction}.}
\end{figure}

\subsection{Instruction \texttt{single-float-sub-instruction}}
\label{mir-instruction-single-float-sub}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed single
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed single float.

The output is the difference between the two inputs.

\refFig{fig-single-float-sub-instruction} shows the Graphviz illustration of the
\texttt{single-float-sub-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-single-float-sub-instruction.pdf_t}
\end{center}
\caption{\label{fig-single-float-sub-instruction}
\texttt{single-float-sub-instruction}.}
\end{figure}

\subsection{Instruction \texttt{single-float-mul-instruction}}
\label{mir-instruction-single-float-mul}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed single
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed single float.

The output is the product of the two inputs.

\refFig{fig-single-float-mul-instruction} shows the Graphviz illustration of the
\texttt{single-float-mul-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-single-float-mul-instruction.pdf_t}
\end{center}
\caption{\label{fig-single-float-mul-instruction}
\texttt{single-float-mul-instruction}.}
\end{figure}

\subsection{Instruction \texttt{single-float-div-instruction}}
\label{mir-instruction-single-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed single
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed single float.

The output is the quotient of the two inputs.

\refFig{fig-single-float-div-instruction} shows the Graphviz illustration of the
\texttt{single-float-div-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-single-float-div-instruction.pdf_t}
\end{center}
\caption{\label{fig-single-float-div-instruction}
\texttt{single-float-div-instruction}.}
\end{figure}

\subsection{Instruction \texttt{double-float-add-instruction}}
\label{mir-instruction-double-float-add}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed double
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed double float.

The output is the sum of the two inputs.

\refFig{fig-double-float-add-instruction} shows the Graphviz illustration of the
\texttt{double-float-add-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-double-float-add-instruction.pdf_t}
\end{center}
\caption{\label{fig-double-float-add-instruction}
\texttt{double-float-add-instruction}.}
\end{figure}

\subsection{Instruction \texttt{double-float-sub-instruction}}
\label{mir-instruction-double-float-sub}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed double
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed double float.

The output is the difference between the two inputs.

\refFig{fig-double-float-sub-instruction} shows the Graphviz illustration of the
\texttt{double-float-sub-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-double-float-sub-instruction.pdf_t}
\end{center}
\caption{\label{fig-double-float-sub-instruction}
\texttt{double-float-sub-instruction}.}
\end{figure}

\subsection{Instruction \texttt{double-float-mul-instruction}}
\label{mir-instruction-double-float-mul}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed double
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed double float.

The output is the product of the two inputs.

\refFig{fig-double-float-mul-instruction} shows the Graphviz illustration of the
\texttt{double-float-mul-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-double-float-mul-instruction.pdf_t}
\end{center}
\caption{\label{fig-double-float-mul-instruction}
\texttt{double-float-mul-instruction}.}
\end{figure}

\subsection{Instruction \texttt{double-float-div-instruction}}
\label{mir-instruction-double-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed double
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed double float.

The output is the quotient of the two inputs.

\refFig{fig-double-float-div-instruction} shows the Graphviz illustration of the
\texttt{double-float-div-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-double-float-div-instruction.pdf_t}
\end{center}
\caption{\label{fig-double-float-div-instruction}
\texttt{double-float-div-instruction}.}
\end{figure}

\subsection{Instruction \texttt{long-float-add-instruction}}
\label{mir-instruction-long-float-add}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed long
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed long float.

The output is the sum of the two inputs.

\refFig{fig-long-float-add-instruction} shows the Graphviz illustration of the
\texttt{long-float-add-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-long-float-add-instruction.pdf_t}
\end{center}
\caption{\label{fig-long-float-add-instruction}
\texttt{long-float-add-instruction}.}
\end{figure}

\subsection{Instruction \texttt{long-float-sub-instruction}}
\label{mir-instruction-long-float-sub}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed long
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed long float.

The output is the difference between the two inputs.

\refFig{fig-long-float-sub-instruction} shows the Graphviz illustration of the
\texttt{long-float-sub-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-long-float-sub-instruction.pdf_t}
\end{center}
\caption{\label{fig-long-float-sub-instruction}
\texttt{long-float-sub-instruction}.}
\end{figure}

\subsection{Instruction \texttt{long-float-mul-instruction}}
\label{mir-instruction-long-float-mul}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed long
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed long float.

The output is the product of the two inputs.

\refFig{fig-long-float-mul-instruction} shows the Graphviz illustration of the
\texttt{long-float-mul-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-long-float-mul-instruction.pdf_t}
\end{center}
\caption{\label{fig-long-float-mul-instruction}
\texttt{long-float-mul-instruction}.}
\end{figure}

\subsection{Instruction \texttt{long-float-div-instruction}}
\label{mir-instruction-long-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed long
  float}.  If the MIR program is \emph{safe}, then control must reach
this instruction only if this restriction is verified.  The output is
also of type unboxed long float.

The output is the quotient of the two inputs.

\refFig{fig-long-float-div-instruction} shows the Graphviz illustration of the
\texttt{long-float-div-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-long-float-div-instruction.pdf_t}
\end{center}
\caption{\label{fig-long-float-div-instruction}
\texttt{long-float-div-instruction}.}
\end{figure}

\section{Data}

\subsection{Input \texttt{constant-input}}

This data type corresponds to constants in source code.  It can only
be used as an \emph{input}.

The slot reader \texttt{value} can be used to access the constant. 

\refFig{fig-constant-input} shows the Graphviz illustration of the
\texttt{constant-input}

\begin{figure}
\begin{center}
\inputfig{fig-constant-input.pdf_t}
\end{center}
\caption{\label{fig-constant-input}
\texttt{constant-input}.}
\end{figure}

\subsection{Input \texttt{global-input}}

This data type corresponds to global function names in source code,
i.e., functions defined in the global environment.  It can only be
used as an \emph{input}.

The slot reader \texttt{name} can be used to access the name of the
global function.

\refFig{fig-global-input} shows the Graphviz illustration of the
\texttt{global-input}

\begin{figure}
\begin{center}
\inputfig{fig-global-input.pdf_t}
\end{center}
\caption{\label{fig-global-input}
\texttt{global-input}.}
\end{figure}

\subsection{Location \texttt{lexical-location}}

This data type corresponds to lexical variable in the source code, and
to temporary variables introduced by the compiler.  It can be used
both as an input and as an output.

The slot reader \texttt{name} can be used to access the name of the
variables.  Notice that different lexical locations have different
\emph{identity} (i.e, they are not \texttt{eq}), but several different
lexical locations may have the same name, due to shadowing.

\refFig{fig-lexical-location} shows the Graphviz illustration of the
\texttt{lexical-location}

\begin{figure}
\begin{center}
\inputfig{fig-lexical-location.pdf_t}
\end{center}
\caption{\label{fig-lexical-location}
\texttt{lexical-location}.}
\end{figure}

\subsection{Location \texttt{simple-location}}

This data type corresponds is a subtype of \texttt{lexical-location}.
It is used for lexical locations that are referred to within a single
function, so that there is no possible capture.  A location of this
type can be allocated in a register or on the stack.  A temporary
variable introduced by the compiler will always turn into a datum of
this type.

\refFig{fig-simple-location} shows the Graphviz illustration of the
\texttt{simple-location}

\begin{figure}
\begin{center}
\inputfig{fig-simple-location.pdf_t}
\end{center}
\caption{\label{fig-simple-location}
\texttt{simple-location}.}
\end{figure}

\subsection{Location \texttt{captured-location}}

This data type corresponds is a subtype of \texttt{lexical-location}.
It is used for lexical locations that are referred to from several
function, i.e., for \emph{captured} variables.  A location of this
type can \emph{not} be allocated in a register or on the stack.
Instead, it has to be allocated in the \emph{static runtime
  environment}. 

\refFig{fig-captured-location} shows the Graphviz illustration of the
\texttt{captured-location}

\begin{figure}
\begin{center}
\inputfig{fig-captured-location.pdf_t}
\end{center}
\caption{\label{fig-captured-location}
\texttt{captured-location}.}
\end{figure}

\section{Operations on MIR programs}

\subsection{Cloning an instruction}

\Defgeneric {clone-instruction} {instruction}

This function creates a copy of \textit{instruction}.

\Defmethod {clone-instruction} {(instruction {\tt instruction})}

The primary method creates an instance of the class of
\textit{instruction}, with the same inputs, outputs and successors
(the lists are not copied). 

Client code must create \texttt{:after} methods to fill in additional
slots. 

\Defun {insert-instruction-before} {new existing}

Insert the instruction \textit{new} before the instruction
\textit{existing}.  After this operation \textit{new} will have
\textit{existing} as its sole successor, and \textit{existing} will
have \textit{new} as its sole predecessor.  For every instruction $p$
that was a predecessor of \textit{existing} before this operation was
executed, after the operation $p$ will be a predecessor of
\textit{new} and \textit{new} will have replaced \textit{existing} as
a successor of $p$.

\Defun {insert-instruction-between} {new existing1 existing2}

Insert the instruction \textit{new} between the instructions
\textit{existing1} and \textit{existing2}, where \textit{existing2} is
a successor of \textit{existing1}.  \textit{existing1} can have any
number of successors and \textit{existing2} can have any number of
predecessors.  \textit{existing1} becomes the sole predecessor of
\textit{new} and \textit{existing2} becomes the sole successor of
\textit{new}.  \textit{new} replaces \textit{existing2} as a successor
of \textit{existing1}, and \textit{existing1} as a predecessor of
\textit{existing2}.

\Defun {insert-instruction-after} {new existing}

Insert \textit{new} after \textit{existing}.  \textit{existing} must
have a single successor.  The effect is to insert \textit{new} between
\textit{existing} and its sole successor.

\Defun {delete-instruction} {instruction}

Delete \textit{instruction}.  \textit{instruction} must have a single
successor.  The sole successor of \textit{instruction} replaces
\textit{instruction} as the successor of every predecessor of
\textit{instruction}.  The predecessors of \textit{instruction} become
the predecessors of the sole successor of \textit{instruction}.

%%  LocalWords:  optimizations reachability unsupplied callee runtime
%%  LocalWords:  subtype backend unboxed
