(cl:in-package #:sicl-cons)

(defun |sublis key=identity test=eq| (alist tree)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (eq tree (car element))
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))
  
(defun |sublis key=identity test=eql| (alist tree)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (eql tree (car element))
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))
  
(defun |sublis key=other test=eq| (alist tree key)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (eq (funcall key tree) (car element))
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))
  
(defun |sublis key=other test=eql| (alist tree key)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (eql (funcall key tree) (car element))
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))
  
(defun |sublis key=identity test=other| (alist tree test)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (funcall test (car element) tree)
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))
  
(defun |sublis key=other-test-other| (alist tree test key)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (funcall test (car element) (funcall key tree))
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))

(defun |sublis key=identity test-not=other| (alist tree test)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (not (funcall test (car element) tree))
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))
  
(defun |sublis key=other test-not=other| (alist tree test key)
  (let ((substitution-p nil))
    (labels ((traverse (tree)
               (let ((entry (with-alist-elements (element alist sublis)
                              (when (not (funcall test (car element) (funcall key tree)))
                                (return element)))))
                 (cond ((not (null entry))
                        (setf substitution-p t)
                        (cdr entry))
                       ((atom tree) tree)
                       (t (cons (traverse (car tree))
                                (traverse (cdr tree))))))))
      (let ((new-tree (traverse tree)))
        (if substitution-p new-tree tree)))))

(defun sublis (alist tree
               &key key (test nil test-given) (test-not nil test-not-given))
  (when (and test-given test-not-given)
    (error 'both-test-and-test-not-given :name 'sublis))
  (if key
      (if test-given
          (if (or (eq test #'eq) (eq test 'eq))
              (|sublis key=other test=eq| alist tree key)
              (if (or (eq test #'eql) (eq test 'eql))
                  (|sublis key=other test=eql| alist tree key)
                  (|sublis key=other-test-other| alist tree test key)))
          (if test-not-given
              (|sublis key=other test-not=other| alist tree test-not key)
              (|sublis key=other test=eql| alist tree key)))
      (if test-given
          (if (or (eq test #'eq) (eq test 'eq))
              (|sublis key=identity test=eq| alist tree)
              (if (or (eq test #'eql) (eq test 'eql))
                  (|sublis key=identity test=eql| alist tree)
                  (|sublis key=identity test=other| alist tree test)))
          (if test-not-given
              (|sublis key=identity test-not=other| alist tree test-not)
              (|sublis key=identity test=eql| alist tree)))))
