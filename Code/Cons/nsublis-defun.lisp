(cl:in-package #:sicl-cons)

(defun |nsublis key=identity test=eq| (alist tree)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eq (car tree) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eq (cdr tree) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eq tree (car element))
                              (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun |nsublis key=identity test=eql| (alist tree)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eql (car tree) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eql (cdr tree) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eql tree (car element))
                              (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun |nsublis key=other test=eq| (alist tree key)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eq (funcall key (car tree)) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eq (funcall key (cdr tree)) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                   (when (eq (funcall key tree) (car element))
                     (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun |nsublis key=other test=eql| (alist tree key)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eql (funcall key (car tree)) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eql (funcall key (cdr tree)) (car element))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                            (when (eql (funcall key tree) (car element))
                              (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun |nsublis key=identity test=other| (alist tree test)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (funcall test (car element) (car tree))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (funcall test (car element) (cdr tree))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                            (when (funcall test (car element) tree)
                              (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun |nsublis key=other-test-other| (alist tree test key)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (funcall test (car element) (funcall key (car tree)))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (funcall test (car element) (funcall key (cdr tree)))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                            (when (funcall test (car element) (funcall key tree))
                              (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun |nsublis key=identity test-not=other| (alist tree test)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (not (funcall test (car element) (car tree)))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (not (funcall test (car element) (cdr tree)))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                            (when (not (funcall test (car element) tree))
                              (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun |nsublis key=other test-not=other| (alist tree test key)
  (labels ((traverse (tree)
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (not (funcall test (car element) (funcall key (car tree))))
                              (return element)))))
               (cond ((not (null entry)) (setf (car tree) (cdr entry)))
                     ((atom (car tree)) nil)
                     (t (traverse (car tree)))))
             (let ((entry (with-alist-elements (element alist nsublis)
                            (when (not (funcall test (car element) (funcall key (cdr tree))))
                              (return element)))))
               (cond ((not (null entry)) (setf (cdr tree) (cdr entry)))
                     ((atom (cdr tree)) nil)
                     (t (traverse (cdr tree)))))))
    (let ((entry (with-alist-elements (element alist nsublis)
                            (when (not (funcall test (car element) (funcall key tree)))
                              (return element)))))
      (cond ((not (null entry)) (cdr entry))
            ((atom tree) tree)
            (t (traverse tree) tree)))))

(defun nsublis (alist tree
                &key key (test nil test-given) (test-not nil test-not-given))
  (when (and test-given test-not-given)
    (error 'both-test-and-test-not-given :name 'nsublis))
  (if key
      (if test-given
          (if (or (eq test #'eq) (eq test 'eq))
              (|nsublis key=other test=eq| alist tree key)
              (if (or (eq test #'eql) (eq test 'eql))
                  (|nsublis key=other test=eql| alist tree key)
                  (|nsublis key=other-test-other| alist tree test key)))
          (if test-not-given
              (|nsublis key=other test-not=other| alist tree test-not key)
              (|nsublis key=other test=eql| alist tree key)))
      (if test-given
          (if (or (eq test #'eq) (eq test 'eq))
              (|nsublis key=identity test=eq| alist tree)
              (if (or (eq test #'eql) (eq test 'eql))
                  (|nsublis key=identity test=eql| alist tree)
                  (|nsublis key=identity test=other| alist tree test)))
          (if test-not-given
              (|nsublis key=identity test-not=other| alist tree test-not)
              (|nsublis key=identity test=eql| alist tree)))))
