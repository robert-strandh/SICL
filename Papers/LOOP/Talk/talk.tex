\documentclass{beamer}
\usepackage[latin1]{inputenc}
\beamertemplateshadingbackground{red!10}{blue!10}
%\usepackage{fancybox}
\usepackage{epsfig}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{url}
%\usepackage{graphics}
%\usepackage{xcolor}
\usepackage{fancybox}
\usepackage{moreverb}
%\usepackage[all]{xy}
\usepackage{listings}
\usepackage{filecontents}
\usepackage{graphicx}

\lstset{
  language=Lisp,
  basicstyle=\scriptsize\ttfamily,
  keywordstyle={},
  commentstyle={},
  stringstyle={}}

\def\inputfig#1{\input #1}
\def\inputeps#1{\includegraphics{#1}}
\def\inputtex#1{\input #1}

\inputtex{logos.tex}

%\definecolor{ORANGE}{named}{Orange}

\definecolor{GREEN}{rgb}{0,0.8,0}
\definecolor{YELLOW}{rgb}{1,1,0}
\definecolor{ORANGE}{rgb}{1,0.647,0}
\definecolor{PURPLE}{rgb}{0.627,0.126,0.941}
\definecolor{PURPLE}{named}{purple}
\definecolor{PINK}{rgb}{1,0.412,0.706}
\definecolor{WHEAT}{rgb}{1,0.8,0.6}
\definecolor{BLUE}{rgb}{0,0,1}
\definecolor{GRAY}{named}{gray}
\definecolor{CYAN}{named}{cyan}

\newcommand{\orchid}[1]{\textcolor{Orchid}{#1}}
\newcommand{\defun}[1]{\orchid{#1}}

\newcommand{\BROWN}[1]{\textcolor{BROWN}{#1}}
\newcommand{\RED}[1]{\textcolor{red}{#1}}
\newcommand{\YELLOW}[1]{\textcolor{YELLOW}{#1}}
\newcommand{\PINK}[1]{\textcolor{PINK}{#1}}
\newcommand{\WHEAT}[1]{\textcolor{wheat}{#1}}
\newcommand{\GREEN}[1]{\textcolor{GREEN}{#1}}
\newcommand{\PURPLE}[1]{\textcolor{PURPLE}{#1}}
\newcommand{\BLACK}[1]{\textcolor{black}{#1}}
\newcommand{\WHITE}[1]{\textcolor{WHITE}{#1}}
\newcommand{\MAGENTA}[1]{\textcolor{MAGENTA}{#1}}
\newcommand{\ORANGE}[1]{\textcolor{ORANGE}{#1}}
\newcommand{\BLUE}[1]{\textcolor{BLUE}{#1}}
\newcommand{\GRAY}[1]{\textcolor{gray}{#1}}
\newcommand{\CYAN}[1]{\textcolor{cyan }{#1}}

\newcommand{\reference}[2]{\textcolor{PINK}{[#1~#2]}}
%\newcommand{\vect}[1]{\stackrel{\rightarrow}{#1}}

% Use some nice templates
\beamertemplatetransparentcovereddynamic

\newcommand{\A}{{\mathbb A}}
\newcommand{\degr}{\mathrm{deg}}

\title{A modern implementation of the \commonlisp{} \texttt{loop} macro}

\author{Robert Strandh}
\institute{
LaBRI, University of Bordeaux
}
\date{May, 2016}

%\inputtex{macros.tex}


\begin{document}
\frame{
\resizebox{3cm}{!}{\includegraphics{Logobx.pdf}}
\hfill
\resizebox{1.5cm}{!}{\includegraphics{labri-logo.pdf}}
\titlepage
\vfill
\small{European Lisp Symposium, Cracow, Poland \hfill ELS2016}
}

\setbeamertemplate{footline}{
\vspace{-1em}
\hspace*{1ex}{~} \GRAY{\insertframenumber/\inserttotalframenumber}
}

\frame{
\frametitle{Context: The \sicl{} project}

https://github.com/robert-strandh/SICL

Several objectives:

\begin{itemize}
\item Create high-quality \emph{modules} for implementors of
  \commonlisp{} systems.
\item Improve existing techniques with respect to algorithms and data
  structures where possible.
\item Improve readability and maintainability of code.
\item Improve documentation.
\item Ultimately, create a new implementation based on these modules.
\end{itemize}
}

\frame{
  \frametitle{MIT LOOP}

  \begin{itemize}
  \item An implementation of the \texttt{loop} macro written at MIT in
    1980 (so prior to the \commonlisp{} standard).
  \item It does not use CLOS, but is nevertheless somewhat extensible.
  \item Parsing clauses is done with no particular parsing technology.
  \item Most current \commonlisp{} implementations use a derivative of it.
  \item The exception is CLISP which has a highly monolithic
    implementation of the \texttt{loop} macro.
  \end{itemize}
}

\frame{
  \frametitle{MIT LOOP is not conforming}

\begin{alltt}
(loop for i from 0 below 10
      sum i
      finally (print i))
\end{alltt}

\vskip 0.3cm
This form should print $9$, but MIT \texttt{loop} prints $10$.

}

\frame{
  \frametitle{MIT LOOP accepts non-conforming code}

\begin{alltt}
(loop until (> i 20)
      for i from 0
      do (print i))
\end{alltt}

\vskip 0.3cm
The \texttt{until} clause is a \emph{main clause} whereas \texttt{for}
is a \emph{variable clause}.
\vskip 0.3cm
But the standard requires variable clauses to precede main clauses.

}

\frame{
  \frametitle{Combinator parsing}

  \begin{itemize}
  \item Initially developed in Haskell.
  \item Elementary parsers are combined using operations such as
    \emph{alternative}, \emph{sequence}, etc.
  \item The technology is \emph{modular} in that individual parsers
    can be textually separated, and no preprocessing of the combined
    grammar is needed.
  \end{itemize}

}

\frame{
  \frametitle{Code generation}

  \begin{itemize}
  \item Clause parsers generate instances of the class \texttt{clause}.
  \item Generic functions are used to extract information from parsed
    clauses:
    \begin{itemize}
    \item Variable bindings including type information.
    \item Termination test.
    \item Iteration.
    \item etc.
    \end{itemize}
  \end{itemize}

}

\frame{
  \frametitle{Future work}

  \begin{itemize}
  \item Improve error reporting by adding clause parsers that
    accept clauses with common errors.
  \item Use external parsing framework supporting full backtracking.
  \item Investigate alternative parsing techniques (Earley).
  \item Code refactoring.
  \item Document how to write extensions.
  \end{itemize}
}

\frame{
  \frametitle{Acknowledgments}

We would like to thank David Murray for providing valuable feedback on
early versions of this paper.
}

\frame{
\frametitle{Thank you}

Questions?
}

%% \frame{\tableofcontents}
%% \bibliography{references}
%% \bibliographystyle{alpha}

\end{document}
