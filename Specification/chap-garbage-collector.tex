\chapter{Garbage collector}

To fully appreciate the contents of this chapter, the reader should
have some basic knowledge of the usual techniques for garbage
collection.  We recommend ``The Garbage Collection Handbook''
\cite{Jones:2011:GCH:2025255} to acquire such basic knowledge.  We
also recommend Paul Wilson's excellent survey paper
\cite{Wilson:1992:UGC:645648.664824}.

We use a per-thread nursery combined with a global allocator for older
objects.

In \refChap{chap-data-representation} we describe the data
representation where every heap allocated object is either a two-word
\texttt{cons} cell or a \emph{standard object} represented as a
two-word \emph{header} where the first of the two words is a tagged
pointer to the class object, and the second of the two words is a
pointer to the \emph{rack} using a special tag for racks.  For the
purpose of garbage collection, in many ways, \texttt{cons} cells and
two-word headers are treated the same way.  For that reason, we refer
to either one as a \emph{dyad}.

We begin this chapter by describing the algorithms used in the global
collector and the nursery collector.  Finally, we describe the
synchronization procedure required for the nursery collectors to
collaborate with the global collector.

\section{Global collector}
\subsection{General description}

The global collector is a concurrent collector, i.e., it runs in
parallel with the mutator threads.  With modern processors, it is
probably practical to assign at least one core more or less
permanently to the global collector.  According to current thinking,
the global collector will be a combination of a mark-and-sweep
collector and a  traditional memory allocator as implemented by
\texttt{malloc()/free()} in a \clanguage{} environment.

We define a global heap divided into two parts called the \emph{dyad
  part} and the \emph{rack part}.  The dyad part is a single vector
consisting of two-word blocks.  This is where dyads are allocated.
The rack part of the global heap is organized as the space managed by
an ordinary memory allocator.  Our adaptation of Doug Lea's memory
allocator that we used for this purpose can be found in
\refApp{app-memory-allocator}.

Since all dyads consist of two words, we can use a mark-and-sweep
collector for these objects without suffering any fragmentation.  The
advantage of a mark-and-sweep collector is that objects will never
move, which is preferable when they are used as keys in hash tables
and when they are used to communicate with code in foreign languages
that assume that an address of an object is fixed once and for all.

Since the rack part of the global heap is managed by an ordinary
memory allocator, the racks also do not move once allocated.  This
fixed position is advantageous for code on some architectures.  For
example, the correspondence between source code location and values of
the program counter does not have to be updated as a result of code
being moved by the garbage collector.

Another great advantage of racks being in a permanent position is that
mutator threads can cache a pointer without the necessity of this
pointer having to be updated as a result of a garbage collection in
the global heap.  Garbage collection in the global heap can therefore
be done in parallel with the execution of the mutator threads.

The global collector cycles through the following phases:

\begin{enumerate}
\item Idle.  In this phase, the global collector is not doing any
  work.
\item Requesting roots.  In this phase, the global collector indicates
  to each running application thread that it needs to transmit its
  part of the global root set to the global collector.  For each
  blocked application thread, another thread (newly spawned or taken
  from a thread pool) does the work on
  its behalf.
\item Waiting for roots.  In this phase, the global collector waits
  for each application thread or each spawned thread to finish
  indicating its part of the global root set.  Dyads and racks are
  treated as independent objects.
\item Mark.  In this phase, the global collector traces and marks the
  live objects starting with the marked roots.
\item Collecting unmarked dyads.  In this phase, the global collector
  scans the dyads and collects the unmarked ones into a linked list.
\item Freeing unmarked racks.  In this phase, the global collector
  iterates through the allocated racks in the rack part of the heap
  and frees unmarked racks.
\item Merging free lists.  In this phase, the global collector merges
  the newly created linked list of unmarked dyads with the existing
  free list.
\item Clearing mark bits.  In this final phase, the mark bits used for
  marking objects as live are cleared.
\end{enumerate}

\subsection{Idle phase}

In this phase the global collector is not doing any work.  Whether it
has allocated threads that are blocked or no threads allocated
remains to be decided.  During this phase, when application threads
request space from the global heap, objects are allocated \emph{white}
(see below for more information on the tri-color technique).

We maintain a free list of dyads to be used to grant requests for
objects by mutator threads.  We start a collection before the free
list is empty so that mutator threads can continue doing useful work
during a garbage collection of the global heap.  If the free list of
dyads ever becomes empty, then mutator threads must wait until more
free dyads become available as a result of a garbage collection of the
global heap.

\subsection{Requesting roots}


See \refSec{sec-garbage-collection-synchronization-between-collectors}
for more details on this phase.  During this phase, when application
threads request space from the global heap, objects are allocated
\emph{black} (see below for more information on the tri-color
technique).

\subsection{Waiting for roots}

In this phase, we wait for each mutator thread to finish reporting its
part of the root set.

\subsection{Mark}

The global collector uses the traditional tri-color marking
technique.  Recall that the tri-color technique works as follows:

\begin{itemize}
\item An object belongs to one of three sets, usually called
  \emph{black}, \emph{white}, and \emph{gray}.
\item Black objects are known to be live.  White objects have not yet
  been traced.  Remaining white objects at the end of a full
  collection are dead.
\item Gray objects represent a frontier between black and white
  objects.  No black object may refer to a white object.
\item Initially, the root objects are colored gray and all remaining
  objects are colored white.
\item In each iteration, a gray object is selected.  The white objects
  it refers to are colored gray, and the object itself is then colored
  black.
\item Collection ends when there are no more gray objects.
\end{itemize}

The root set is determined by requesting that each application thread
trace live objects from their respective roots, and informing the
global collector when this procedure reaches an object allocated in
the global heap. For application threads that are blocked, for example
waiting for input or output, the global collector spawns a thread to
run the garbage collector on behalf of the application thread.

The global collector maintains two bitmaps for the purpose of marking
dyads, one for black objects and one for gray objects.  Each bitmap
contains a bit for every dyad.  In addition, the gray bitmap has a
multi-level \emph{index}, making it possible to find an arbitrary gray
object in only a few cycles.  For each 64-bit word in the primary
bitmap, a bit in a secondary bitmap is maintained.  The bit in the
secondary bitmap is set if there is at least one bit set in the 64-bit
word in the primary bitmap.  Additional levels of index exist until
the last level fits in a single 64-bit word.

To include an object in the set of gray objects, the address is used
to determine a bit position in the primary bitmap.  Before the
corresponding bit is set, the 64-bit word that this bit is contained
in is tested to see whether it has all bits cleared.  If that is the
case, the bit position in the secondary bitmap is determined, and
recursively set in the same way.  Finally the bit is set.

To exclude an object from the set of gray objects, the address is used
to determine a bit position in the primary bitmap. The bit is then
cleared.  If this operation results in a 64-bit word that has all bits
cleared, then the bit position in the
secondary bitmap is determined, and recursively cleared in the same
way.

To find a gray object, start at the top-level index and find an
arbitrary position contining a bit that is set.  This position
corresponds to an index in the next-level index.  Repeat the procedure
until the primary bitmap is reached.

Since the operation of finding a gray object might be somewhat costly,
we also keep a fixed-size cache of gray objects, organized as a stack
represented as a vector.  Gray objects are initially taken from the
cache.  Only when the cache is empty is the more costly technique
used.  Whenever the objects referred to by a gray object are colored
gray, they are also included in the cache (provided there is room in
the cache).  The cache could for instance be a vector with around a
million elements.  Such a vector would occupy only 8 megabytes of
memory which is comparable to the space taken up by the gray bitmaps.

Every rack has a (single) mark bit as well.  Since there is plenty of
room in the chunk that is used for the rack, there is no need to use
separate bitmaps for the mark bits of the racks.  Instead, a bit in
the \emph{size} field described in \refApp{app-memory-allocator} is
used.

Each rack has a single mark bit, so it can be only black or white.
This invariant is simply maintained by the recursive scanning of its
contained object, whenever it is found to be live.  The reason for not
allowing racks to be gray is that we would then need to scan the
entire rack zone for gray objects, or maintain additional separate
mark bits with indices, just as we do for dyads.
\footnote{We could allow for a rack to be gray, provided there is room
  for it in the fixed-size cache.  We could even evict a dyad from the
  cache to make room for a rack.  If the global collector never colors
  a rack gray, and instead always recursively scans it and colors the
  object it contains gray instead, then the only situation where a
  rack is colored gray would be when the mutator has a pointer to a
  rack with no pointer to the header, so there will be very few racks
  that are gray.  The reason we would like to allow for a rack to be
  gray sometimes is so that the mutator will not have unbounded pauses
  when it is asked for roots.}

\subsection{Collecting unmarked dyads}

We collect unmarked dyads into a list that is separate from the free
list used to grant request for allocations by mutator threads.  We do
not want requests for allocations by mutator threads to be granted
from this list until we have freed the racks these dyads refer to.

If the number of dyads recovered is insufficient, i.e. a new
allocation would be triggered very soon, more memory is requested from
the system and used for dyads.

\subsection{Freeing unmarked racks}

During this phase, the racks that are indicated as allocated are
traversed, and any rack that is unmarked is freed.

\subsection{Merging free lists}

Once the racks of unmarked dyads have been freed, the two free lists
are merged into a single one.

\subsection{Clearing mark bits}

Finally, we clear all the bitmaps used for marking, and we either
enter the idle phase, or start a new collection, depending on the
number of dyads left in the free list.

\subsection{Write barrier}

The global collector is subject to a write barrier.  Let G be some
object in the global heap, and let N be some object in a nursery.  The
write barrier must prevent the existence of a reference from G to N.
Therefore, when attempt is made to create such a reference, N and the
objects in its transitive closure are first moved to the global heap.
As a result, there are no references from the global heap to objects
in any nursery.  The write barrier is implemented as a test, emitted
by the compiler, to determine:

\begin{enumerate}
\item whether the object written to is indeed an object in the global
  heap, and
\item whether the datum being written is a reference to a
  heap-allocated object (as opposed to an immediate object).
\end{enumerate}

In many cases, this test can be omitted as a result of \emph{type
  inference}, for instance if the datum being written can be
determined at compile time to be an immediate object.

The write barrier is tripped whether the reference to be stored is to
an object in the global heap or to an object in the local heap.  In
the first case, the write barrier is used to make sure there is not a
reference to a white object stored in a black object.  In the second
case, the write barrier is used to trigger a migration of local
objects to the global heap.

\subsection{Protocol}

The names of these functions are exported by the package named
\texttt{sicl-global-allocator}.

\Defun {copy-object} {object}

This function takes an object that is allocated in some thread-local
heap, copies it, and returns a copy that is allocated in the global
heap.  All the objects referred to by \textit{object}, including the
class of a standard object, must either be immediate objects, or
objects located in the global heap,

\Defun {make-array} {dimensions \key element-type initial-element
  initial-contents adjustable fill-pointer}

This function is similar to the \commonlisp{} function with the same
name.  The difference is that this function can not be used to
allocate displaced arrays.  This function can be used by client code
to allocate arrays that are too big to be allocated in the
thread-local heap.  All arguments must either be immediate objects, or
objects located in the global heap.

\Defun {allocate-rack} {size}

Allocate a rack containing \textit{size} words and return an untagged
pointer to it.  Because the pointer is untagged, it will look like a
fixnum.  If the reference returned by this function is dropped and not
passed to \texttt{allocate-header} then the corresponding memory is
lost forever.

\Defun {allocate-header} {class rack}

This function allocates a new two-word header and returns a tagged
pointer to it.  The argument \textit{class} is the class of the object
to be constructed.  The argument \textit{rack} is the rack that holds
the data contained in the object to be constructed.  The \texttt{rack}
argument must be an untagged pointer to the rack.  The tag specific to
racks will be added by this function.

\Defun {cons} {car cdr}

This function allocates a new two-word \texttt{cons} cell and returns
a tagged pointer to it.  The arguments have the same meaning as for
the standard \commonlisp{} function \texttt{cons}.

\section{Nursery collector}

\subsection{General description}

The nursery should be fairly small so as to guarantee short delays, a
few megabytes at most.  Instead of a traditional copying collector in
which objects that survive a collection are promoted, we use a
\emph{sliding collector} for the nursery.  Such a collector gives a
very precise idea of the age of different objects, so objects would
always be promoted in the order of oldest to youngest.  This
technique avoids the problem in traditional copying collectors where
the allocation of some temporary objects is immediately followed by
a collection, so these objects are promoted even though they are
likely to die soon after the collection.  In a sliding collector,
promotion will happen only when a collection leaves insufficient space
in the nursery, at which point only the number of objects required to
free up enough memory would be promoted, and in the strict order of
oldest to youngest.%
\footnote{Though, we have an invariant that stipulates that there are
  no references from any object in the global heap to any object in a
  nursery.  For that reason, if (as a result of a side effect) an old
  object in the nursery refers to a younger object in the nursery, and
  the older object is promoted, then the younger object must be
  promoted as well.}

\subsection{Allocation}

The nursery allocator maintains two pointers into the nursery heap,
namely the \emph{dyad free pointer} and the \emph{rack free
  pointer}.  The dyad free pointer always has a smaller value than
the rack free pointer.  These pointers are illustrated in
\refFig{fig-nursery-pointers}.

\begin{figure}
\begin{center}
\inputfig{fig-nursery-pointers.pdf_t}
\end{center}
\caption{\label{fig-nursery-pointers}
Allocation pointers in the nursery.}
\end{figure}

To allocate a dyad, the value returned is the existing value of the
dyad free pointer with appropriate tag bits added.  Before this value
is returned, the dyad free pointer is incremented by a value
corresponding to two full words.

To allocate a rack, the rack free pointer is first decremented by a
value corresponding to the number of words in the rack.  The new value
of the rack free pointer is then returned.  The tag bits ($111$) for a
rack are added.

When a request for allocation would result in less than six free words
left in the nursery, a collection is first triggered before the
request is granted.  The reason we need these six spare words is
explained in \refSec{sec-garbage-collection-break-table-build-phase}.

\subsection{Finding roots}
\label{sec-garbage-collection-finding-roots}

Several of the phases of the nursery collector involve finding every
\emph{root}, i.e., every \commonlisp{} object that is currently in a
processor register or on the stack.  What is done to the object once
it is found, depends on the phase.

Finding the roots is a fairly complicated procedure, which is probably
why some implementations prefer traversing the stack
\emph{conservatively}, i.e., considering every word on the stack that
\emph{might} be a root to actually \emph{be} one.  But such tricks
complicate other aspects of the garbage collector.

In \sysname{} we use \emph{precise} stack traversal, meaning that we
know exactly when a location contains a root and when it does not.

This precise traversal is complicated by the fact that some registers
are so called \emph{callee saves} registers, meaning that a particular
function invocation does not save the register to the stack before
making a function call, and instead it relies on the first function
on the call chain that needs to use the register to save it and
restore it after use.  A direct consequence of this scheme is that a
register or a stack location close to the top of the stack may contain
a datum that belongs to a function invocation arbitrarily further down
the stack, and whether that register or stack location is a root can
only be determined by knowing the current value of the program counter
in that function invocation.

To find the roots owned by each stack frame, we use the \emph{return
  address} stored in the stack frame immediately above the one we are
interested in.  That return address is used to access the \emph{frame
  map} and the \emph{callee-saves map} as described in
\refSec{data-representation-code-objects}.  Recall that the
\emph{frame map} is a bitmap that contains an element for each stack
location containing a \commonlisp{} object that might be heap
allocated.  For a callee-saves register that might contain a
heap-allocated \commonlisp{} object, the frame map indicates the frame
location where the previous value of the register was stored.  Also
recall that the callee-saves map contains an entry for each
callee-saves register.  The value of an entry is the stack location
where the previous value of the register was stored, or $0$ of the
register is not used by the current invocation.

When the stack traversal starts, the top stack frame belongs to the
garbage collector itself.  That frame does not contain any roots.  We
maintain a table called \emph{register contents table} of contents of
callee-saves registers.  The table is initially filled with the
current contents of those real registers.

The stack is then traversed, frame by frame, starting with the second
one from the top, and using the return address in the top frame.
Initially, the register contents table contains the current value of
those registers when the root-finding function was called.

When a stack frame is visited, the \emph{callee-saves map} for the
current stack frame is consulted.  Recall that this map is indexed by
a callee-saves register and contains a stack location in the current
frame.  The values of the register entry in the register contents
table and the corresponding stack frame are swapped.  After these
swaps, the register contents table contains the callee-saves
registers for the next frame, and the frame locations contain the
value of the callee-saved registers owned by the invocation of this
frame.

Next, the \emph{frame map} is used to determine location of roots.
When those roots have been processed, the next frame is visited.

When the bottom frame of the stack has been processed, we back up by
applying the information in the callee-saves map again, thereby
swapping back to the correct contents of the stack frame.

As an example of finding the roots, consider a situation where we have
three callee-saves registers ($0$, $1$, and $2$), and three stack
frames plus the one running the root-finding function.  Let us call
these stack frames $A$, $B$, and $C$, in that order of invocation.
Each stack frame has three local variables.  Let us call them $a_1$,
$a_2$, $a_3$, $b_1$, $b_2$, $b_3$, $c_1$, $c_2$, and $c_3$.  The
variables are kept by each stack frame as follows:

\begin{itemize}
\item For stack frame $A$, every variable contains a \commonlisp{}
  object.  The variables $a_1$ and $a_2$ are kept in callee-saves
  registers $0$ and $2$ respectively, so the callers values of those
  registers have been saved in stack locations $-2$ and $-3$
  respectively, but this is the bottom frame, so those saved values
  contain random data.  The variable $a_3$ is kept in a caller-saves
  register, so it has been saved to stack location $-4$ before the
  call that created the stack frame $B$.
\item For stack frame $B$, every variable contains a \commonlisp{}
  object.  The variables $b_1$ and $b_2$ are kept in callee-saves
  registers $1$ and $2$ respectively, so the callers values of those
  registers have been saved in stack locations $-2$ and $-3$
  respectively.  Saved location $-3$ contains $a_2$, but saved
  location $-2$ contains random data, because no previous invocation
  has used it for any \commonlisp{} object.  The variable $b_3$ is
  kept in a caller-saves register, so it has been saved to stack
  location $-4$ before that call created the stack frame $C$.
\item Stack frame $C$ keeps $c_1$ and $c_2$ in callee-saves registers
  $0$ and $2$, respectively, so it has saved the callers values of
  those registers in stack locations $-2$ and $-3$ respectively.  But
  only $c_1$ is a \commonlisp{} object, whereas $c_2$ is some immediate
  machine value.  Saved location $-2$ contains $a_1$, and saved
  location $-3$ contains $b_2$.  It keeps $c_3$ in a caller-saves
  register, so it has been saved to stack location $-4$ before the
  root-finding function is invoked.
\end{itemize}

This initial situation is illustrated in
\refFig{fig-root-finding-example-1}.

\begin{figure}
\begin{center}
\inputfig{fig-root-finding-example-1.pdf_t}
\end{center}
\caption{\label{fig-root-finding-example-1}
Finding roots, situation before first iteration.}
\end{figure}

In the first iteration, we start by consulting the callee-saves map.
Entries that are not $0$ are used to determine a stack location.  The
contents of that stack location is swapped with the corresponding
element in the register contents table.  The result of this operation
is shown in \refFig{fig-root-finding-example-1b}.

\begin{figure}
\begin{center}
\inputfig{fig-root-finding-example-1b.pdf_t}
\end{center}
\caption{\label{fig-root-finding-example-1b}
Finding roots, first iteration.}
\end{figure}

As \refFig{fig-root-finding-example-1b} shows, stack frame $C$ now
contains only data belonging to this invocation.  The \texttt{frame
  map} is now consulted.  It indicates that stack locations $-2$ and
$-4$ contain \commonlisp{} objects, so $c_1$ and $c_3$ are identified
as roots.

The initial situation of the second iteration is shown in
\refFig{fig-root-finding-example-2}.

\begin{figure}
\begin{center}
\inputfig{fig-root-finding-example-2.pdf_t}
\end{center}
\caption{\label{fig-root-finding-example-2}
Finding roots, situation before second iteration.}
\end{figure}

In the second iteration, we start by consulting the callee-saves map.
Entries that are not $0$ are used to determine a stack location.  The
contents of that stack location is swapped with the corresponding
element in the register contents table.  The result of this operation
is shown in \refFig{fig-root-finding-example-2b}.

\begin{figure}
\begin{center}
\inputfig{fig-root-finding-example-2b.pdf_t}
\end{center}
\caption{\label{fig-root-finding-example-2b}
Finding roots, second iteration.}
\end{figure}

As \refFig{fig-root-finding-example-2b} shows, stack frame $B$ now
contains only data belonging to this invocation.  The \texttt{frame
  map} is now consulted.  It indicates that stack locations $-2$,
$-3$, and $-4$ contain \commonlisp{} objects, so $b_1$, $b_2$, and
$b_3$ are identified as roots.

The initial situation of the third iteration is shown in
\refFig{fig-root-finding-example-3}.

\begin{figure}
\begin{center}
\inputfig{fig-root-finding-example-3.pdf_t}
\end{center}
\caption{\label{fig-root-finding-example-3}
Finding roots, situation before third iteration.}
\end{figure}

In the third iteration, we start by consulting the callee-saves map.
Entries that are not $0$ are used to determine a stack location.  The
contents of that stack location is swapped with the corresponding
element in the register contents table.  The result of this operation
is shown in \refFig{fig-root-finding-example-3b}.

\begin{figure}
\begin{center}
\inputfig{fig-root-finding-example-3b.pdf_t}
\end{center}
\caption{\label{fig-root-finding-example-3b}
Finding roots, third iteration.}
\end{figure}

As \refFig{fig-root-finding-example-3b} shows, stack frame $C$ now
contains only data belonging to this invocation.  The \texttt{frame
  map} is now consulted.  It indicates that stack locations $-2$,
$-3$, and $-4$ contain \commonlisp{} objects, so $a_1$, $a_2$, and
$a_3$ are identified as roots.

We have now reached the bottom stack frame, so we have correctly
identified all the roots.  To restore the stack to its initial state,
this procedure must be executed in reverse order.  However, the stack
can be kept in this state until roots need to be found a second time.

While it is possible for the garbage collector to handle pointers into
arbitrary positions of a rack,%
\footnote{Recall that a pointer to a rack is tagged.  The same tag is
  used for a pointer to any element of a rack.}
in such a situation, there must also be an identifiable root that
refers to the corresponding header.  Otherwise, it may be the case
that the object is incorrectly determined to be dead.

\subsection{Mark phase}

The mark phase uses a separate bitmap called the \emph{live bitmap}.
It has a bit for every word with an even index in the nursery.  We do
not need a bit for every word, because only headers will be marked.
After the mark phase has finished, if a bit is set in the bitmap, it
means that the corresponding object is live.  The live bitmap is
initialized so that all bits are cleared before the mark phase begins.

The mark phase starts by finding the roots as described in
\refSec{sec-garbage-collection-finding-roots}.  If the root is a
pointer to a dyad in the nursery, the corresponding bit in the live
bitmap is set to $1$.  If the root is a pointer to a rack in the
nursery, the root is invalidated by storing a $0$ in it.  This
invalidation has the effect that the test for sameness of rack before
and after the function call will fail, and the rack will be reloaded
from the header.

A flag determines whether a reference to an object allocated in the
global heap should be marked or not.  This flag is set when the local
garbage collection was requested by the global garbage collector, and
cleared when the local garbage collection was performed as a result of
the local heap being full.  If a traced object is located in the
global heap and the flag is set, then the global collector is informed
that it is live.  If the object is located in the nursery, the
corresponding bits in the live bitmap are set.  If the root contains a
pointer to a rack in the global heap, and the flag is set, then the
global collector is informed that this rack is live.

Once the roots are found, the dyads marked as live in the nursery are
traced according to whether the dyad is a \texttt{cons} cell or a
standard object.  Standard objects have a rack pointer with a reserved
tag ($111$) in the second word, whereas \texttt{cons} cells do not.
If the object is a standard object, then it is traced according to the
layout information in the second word of the rack.  We do not use
information found in the class of the object, because the object may
be obsolete, and in that case, the rack layout may not correspond to
the information in the class.  The words that may contain live object
of the rack are recursively visited.  If the object is a \texttt{cons}
cell, the \texttt{car} and the \texttt{cdr} are recursively visited.
Tracing stops when an object is reached that has already been traced,
or when an object is reached that is located in the global heap.

The mark phase maintains an integer variable named \emph{live space}.
It is initialized to $0$ at the beginning of the mark phase.  For
every unmarked object in the nursery that is encountered, the value of
the variable is incremented by the size of that object.  If the object
is a standard object, then not only is the rack traced, but the size
of the rack is added to the value of the variable as well.  When the
mark phase is finished, this variable contains the total amount of
live space in the nursery.

At the end of the mark phase, if the flag is set, a \emph{signal}
operation is performed on a semaphore used for synchronization between
the local and the global garbage collector.

\subsection{Promotion phase}

After the mark phase has finished, the value of the variable
\emph{live space} is used to determine whether some of the
objects in the nursery should be \emph{promoted}.  Good threshold
values are yet to be determined, but we think that if more than half
the nursery contains live objects, then some objects should be
promoted.  The higher the threshold, the more likely it is that a
collection will be triggered soon after the current one.  The lower
the threshold, the more likely it is for young objects to be promoted
even though they are likely to die soon.

The other threshold value to be determined is how many objects should
be promoted.  We think that, after promotion, around one fourth of the
nursery should contain live objects.  The higher the threshold, the
more likely it is for another promotion to be triggered during the
next invocation of the collector.  The lower the threshold, the more
likely it is for young objects to be promoted even though they are
likely to die soon.

The promotion phase uses a bitmap called the \emph{promotion bitmap}
again containing one bit per word in the nursery.  This bitmap is
initialized so that all its bits are cleared.  When an object has been
promoted, the first word of the dyad contains a \emph{forwarding
  pointer} pointing to the promoted object in the global heap, and the
bit in the promotion bitmap corresponding to the first word of the
dyad is set.  Similarly, when a standard object has been promoted,
every word in the rack that has a $1$ in the live bitmap contains a
forwarding pointer, pointing to the new word in the global heap, and
the bit in the promotion bitmap corresponding to that word is set.
The reason for treating the rack this way is that a stack frame may
contain local variables that are rack pointers, and those variables
must be updated when the object owning the rack has been promoted.  We
do this by replacing the contents of the variable with the forwarding
pointer when the corresponding bit in the promotion bitmap is set.

To preserve the invariant of the garbage collector that there must be
no references from the global heap to a nursery, whenever an object is
promoted, other objects referenced from the promoted object, must be
recursively promoted.

The promotion phase executes a loop over the live objects that have
not yet been promoted in the nursery, starting from the one with the
smallest address.  An object is skipped if it not live, as indicated
by the bit in the live bitmap, and an object is skipped if it has
already been promoted, as indicated by the bit in the promotion
bitmap.  If the object is not to be skipped, it is promoted.  This
means that a \emph{copy} of the object is allocated in the global
heap.  A forward reference is stored in the first word of the dyad
of the original object, and a bit is set in the promotion bitmap.
Similarly, the contents of every word of the rack that has a
corresponding $1$ in the promotion bitmap is replaced by a
forwarding pointer.  Notice that, during this phase, there will
be references from the global heap to the nursery, but these
references will never be followed by the global collector, and they
will disappear at the end of the promotion phase.

The newly promoted \emph{copy} is then traced in much the same way as
objects are traced during the mark phase.  An object is traced by
recursively visiting its contained objects.  When a visited object
reference indicates that it has already been promoted, as indicated by
the corresponding bit being set in the promotion bitmap, the reference
is replaced by the forward reference stored in the first word of the
dyad in the nursery, and tracing stops.  If the visited object has
not yet been promoted, then a copy is allocated in the global heap as
described above.  The corresponding bits in the promotion bitmap are set
and forwarding pointers are stored, again as above, and the copy is
recursively traced.  Notice that if a functional programming style is
used, all objects referred to by the initial copy will have already
been promoted.  Only side effects can result in an object containing a
reference to an object that was allocated later on in the nursery.
Therefore, if a functional style is used, the recursion will be very
shallow.  For every object that is being promoted, we keep a tally of
the amount of total space that has been promoted this way.  When the
total amount of space is greater than or equal to the threshold that
has been determined, the outer loop stops.  We can not, however, stop
the tracing in each iteration, because stopping it prematurely means
that there will be references from the global heap to the nursery
remaining after this phase.

When a sufficient number of objects have been promoted, the stack is
traversed to find roots that need to be modified as a result of object
having been promoted.  We consult the frame map of each frame to
determine the roots.  Whether the root contains a pointer to a dyad or
to some element of a rack, the promotion bitmap for that pointer is
consulted.  If it is set, then the root is replaced by the forwarding
pointer stored in the dyad or the rack.

Finally, every live object in the nursery that has not been promoted
is scanned to determine any reference to a promoted object.  Such a
reference is replaced by the forward reference as before.

When every relevant reference to a promoted object has been updated
this way, the promotion bitmap is subtracted from the live
bitmap.  This way, the live bitmap has a bit set only for live
objects that are still in the nursery.

\subsection{Compaction phase}

In the \emph{compaction phase}, the live bitmaps is used to slide
dyads to the beginning of the nursery heap and to slide racks to the
end of the nursery heap.  A \emph{source} pointer follows live words
to be copied, and a \emph{target} pointer follows available words.

\subsection{Break table build phase}
\label{sec-garbage-collection-break-table-build-phase}

In the \emph{table build phase}, the live bitmap is used to construct
two \emph{break tables} between the new locations of the dyad free
pointer and the rack free pointer after compaction.  Each table has
the format $a_0, d_0, a_1, d_1, \ldots, a_n, d_n, a_{n+1}$ where $a_i$
is an address and $d_i$ is a \emph{delta} or an \emph{offset}.  The
meaning of the elements of a table is that an address that was
originally between $a_i$ and $a_{i+1}$ should be updated by having
$d_i$ added to it.  One break table is built for dyads and another
break table is built for racks.  In the worst case, each of these
tables may contain three more words than there are free words
available for it.  This is the reason why a collection is triggered
when granting a request for allocation would result in fewer than six
words left in the nursery heap.

We use \emph{binary search} to find an entry in a break table.

\subsection{Pointer adjustment phase}

Once the break tables are built, the stack is scanned to find roots, and it
is also restored to its initial state as described in
\refSec{sec-garbage-collection-finding-roots}.  For each root that
contains a pointer to the nursery, we determine whether it is pointer
to a dyad or to a rack, and consult the corresponding break table to
determine a value to be added to the current one.  Notice that we can
handle pointers to any arbitrary position in a rack.  The
corresponding break table will indicate the correct amount for such
internal pointers as well.

Next, dyads in the nursery are traversed.  For a \texttt{cons} cell,
the first break table is consulted in order to adjust both the
\texttt{car} and the \texttt{cdr}.  For a standard object, the first
break table is consulted in order to adjust the \texttt{class} slot
and the second break table is consulted in order to adjust the
\texttt{rack} slot.  Once the rack slot has been adjusted, the rack is
traversed according to the class in order to determine what words of
the rack contain \commonlisp{} objects.  For each such word, if it is
a heap-allocated object, the first break table is consulted in order
to adjust its value.

In the \emph{adjust phase}, dyads and racks are scanned, and fields
containing pointers are adjusted according to the offset table.  The
offset table is searched using binary search, except that a simple
caching scheme is used to avoid a full binary search in nearly all
cases.

\section{Synchronization between collectors}
\label{sec-garbage-collection-synchronization-between-collectors}

Since each thread is responsible for collecting its own heap and since
the global collector can not run until every application thread has
run its own collector, we need to find a way of dealing with threads
that are stopped for any reason, for instance waiting for
input/output.

We think that in cases like that, one of the threads of the global
collector would run the garbage collector on behalf of the stopped
thread.  During the execution of the garbage collector, if the stopped
thread becomes unstopped, it must then be prevented from running
application code until the collection has run to completion.

We do this by introducing a variable and two semaphores for each
application thread. The variable and the semaphores are shared between
that thread and the global collector threads.  The variable has 4 bit
positions with the following meanings:

\begin{itemize}
\item \texttt{application-blocked} meaning that the application thread
  might be blocked when the bit is set, and is therefore not capable
  of executing the local garbage collector.  This bit is both set and
  cleared by the application thread.
\item \texttt{gc-requested} meaning that the global collector has
  requested that the application thread run the garbage collector.
  This bit is set by the global collector and cleared by the
  application thread.
\item \texttt{gc-in-progress} meaning that the global collector is
  running the nursery garbage collector on behalf of the thread.  This
  bit is both set and cleared by the global collector.
\item \texttt{application-waiting} meaning that the application is
  waiting for the global collector to finish the garbage collection on
  behalf of the application thread.
\end{itemize}

The two semaphores work as follows:

\begin{itemize}
\item \texttt{global-gc-may-proceed}.  This semaphore is initialized to
  $0$.  When the global collector requests that an application thread
  run the local garbage collector it waits on this semaphore.  The
  application thread signals this semaphore, indicating that all
  objects in the global heap reachable from the local heap have been
  marked.
\item \texttt{application-may-execute}.  This semaphore is initialized
  to $0$.  When an application thread awakes after having been
  blocked, it checks whether the global collector is currently
  executing on behalf of this application thread.  If so, the
  application thread waits on this semaphore.  When the global
  collector has finished executing on behalf of this thread, it
  signals this semaphore, allowing the application thread to continue
  its execution.
\end{itemize}

\subsection{Running application thread}

At every safe point (function call, function return, and a branch to
an inferior address%
\footnote{To minimize the overhead in case of a very tight loop, we
  will use loop unrolling so that a branch to an inferior address will
  be less frequent.}), the application thread consults the shared
variable.  If the \texttt{gc-requested} bit is set, then it clears
that bit and runs the nursery garbage collector.  At the end of the
collection, it signals the \texttt{global-gc-may-proceed} semaphore
indicating to the global collector that it has finished, and finally
continues the application thread.  No synchronization is required to
read the shared variable, because once the \texttt{gc-request} bit is
set, no other bit is going to move as the result of any action on the
part of the global collector.

\subsection{Application thread about to block}

When there is a possibility that an application thread is about to
block, for example when it is about to execute some input or output
operation,  it must inform the global collector that it might be
unable to run the local garbage collector itself, and that the global
collector may have to run it on behalf of the application thread.

The application starts by reading the shared variable into an ordinary
lexical variable.  If the \texttt{gc-request} bit is set, it clears
the bit and runs the nursery garbage collector.  At the end of the
collection, it signals the \texttt{global-gc-may-proceed} semaphore
indicating to the global collector that it has finished, and then
starts over by reading the variable again.  This action is repeated
until the \texttt{gc-request} bit is cleared.

When the \texttt{gc-request} bit is cleared, it sets the
\texttt{application-blocked} bit in a second local copy of the shared
variable.  It then performs a CAS operation to set the
\texttt{application-blocked} bit in the shared variable.  Should this
operation fail, then it means that the \texttt{gc-request} bit has
been set since the shared variable was read the first time.  The
application thread then starts the entire operation over again.

If the CAS operation succeeds, it means that the global collector has
been informed that, if it needs for this nursery heap to be garbage
collected, it has to do it on behalf of the thread.  The application
thread can now perform the operation that might block the thread.

\subsection{Application thread waking up after block}

When the application thread wakes up after having been blocked, there
is a possibility that the global garbage collector is in the process
of running the nursery collector on behalf of the application thread.
If that is the case, then the application thread must wait until the
garbage collection is finished.

The application thread starts by reading the shared variable into an
ordinary lexical variable, and it also makes a second copy.  If the
\texttt{gc-in-progress} bit is cleared, it then clears the
\texttt{application-blocked} bit in the second copy and performs a CAS
operation.  If the CAS operation succeeds, this means that the global
collector is not running on behalf of the application thread, and will
not do so because it has been informed that the application thread is
not blocked.  The application thread then returns to its normal
operation without any further action.

If the CAS operation fails, then that means that the global collector
has started a collection on behalf of the application thread since the
shared variable was read.  Then the application thread
reads the shared variable again.  If the
\texttt{gc-in-progress} bit is set, then the application thread clears
the \texttt{application-blocked} bit and sets the
\texttt{application-waiting} bit in the second local copy of the
shared variable.  It then performs a CAS operation.  If the CAS
operation succeeds, it means that the global collector is still
running the nursery collector on behalf of the application thread, and
that the global collector has been informed that, when the nursery
collection is finished, it should signal the
\texttt{application-may-execute} semaphore.

\subsection{Preparing for a global collection}

Before a global collection can take place, each nursery must first be
collected, and references from the nurseries to the global heap must
be marked so that the global collector will keep the referenced
objects.

For each application thread, the following actions are performed:

The contents of the shared variable is read into an ordinary lexical
variable, and a second copy of it is made.  The
\texttt{application-blocked} bit is examined.

\begin{enumerate}
\item If it is cleared, then the \texttt{gc-request} bit is set in the
  second copy, and a CAS operation is attempted.
  \begin{enumerate}
  \item If the operation succeeds, then that means that the
    application thread is still not blocked and it has been properly
    informed that it is expected to run a nursery collection.  The
    \texttt{global-gc-may-proceed} semaphore for this application
    thread is added to a set of such semaphores.
  \item If the operation fails, then that means that the application
    has been blocked in the meantime.  The entire operation is then
    restarted by reading the shared variable again.
  \end{enumerate}
\item If it is set, then the application is blocked.  Then the
  \texttt{gc-in-progress} bit of the second copy is set, and a CAS
  operation is attempted.
  \begin{enumerate}
  \item If the operation succeeds, then that means that the
    application thread is still blocked, and that it has been properly
    informed that a nursery collection on its behalf is pending.  A
    new thread (or an existing one from a pool) is assigned to do a
    nursery collection on behalf of the application thread, and the
    thread is added to a set of such threads.
    \item If the operation fails, then that means that the application
      is no longer blocked.  The entire operation is then restarted by
      reading the shared variable again.
  \end{enumerate}
\end{enumerate}

When all the application threads have been processed this way, the
global garbage collector executes a \emph{wait} operation sequentially
on each semaphore in the saved set.

Then the global collector waits for each the threads in the set of
threads doing a nursery collection on behalf of an application thread
to finish.  When such a thread finishes, the shared variable is read
into an ordinary lexical variable and a second copy is made.  The
\texttt{application-waiting} bit is examined.

\begin{enumerate}
\item If it is set, the global collector clears the bit, clears the
  \texttt{gc-in-progress} bit, and executes a \emph{signal} operation
  on the \texttt{application-may-execute} semaphore.  No further
  synchronization is required.
\item  If it is cleared, then that means that the application is still
  blocked.  Then the global collector clears the
  \texttt{gc-in-progress} bit in the second copy and attempts a CAS
  operation.
  \begin{enumerate}
  \item If the CAS operation succeeds, then it means that the
    operation is still blocked, and it has been informed that it can
    safely execute application code when it wakes up.
  \item If the CAS operation fails, then the application may no longer be
    blocked.  The entire operation is then restarted by reading the
    shared variable again.
  \end{enumerate}
\end{enumerate}

\section{Implementation}

In most systems, the garbage collector is implemented in some language
other than \commonlisp{}.  However, we imagine using \commonlisp{}
together with some additional low-level primitives for accessing
memory by address instead.

%%  LocalWords:  mutator dyad dyads
